use tracing::{error, info};

use crate::config::{AutoMergePolicy, Config, RepoConfig};
use crate::error::Result;
use crate::git;
use crate::github::client::GitHubClient;
use crate::github::issue::ForgeIssue;
use crate::pipeline::execute::ExecuteResult;
use crate::state::tracker::{IssueStatus, SharedState};

pub struct WorkerOutput {
    pub issue: ForgeIssue,
    pub result: ExecuteResult,
    pub repo_config_name: String,
}

pub async fn integrate(
    outputs: Vec<WorkerOutput>,
    config: &Config,
    github: &GitHubClient,
    state: &SharedState,
) -> Result<()> {
    let (failures, successes): (Vec<_>, Vec<_>) = outputs
        .into_iter()
        .partition(|o| !matches!(o.result, ExecuteResult::Success { .. }));

    // Report failures first
    for output in &failures {
        let repo_config = config
            .find_repo(&output.repo_config_name)
            .expect("repo config should exist");
        if let Err(e) = crate::pipeline::report::report(
            &output.issue,
            &output.result,
            repo_config,
            github,
            state,
            &config.settings.worktree_dir,
        )
        .await
        {
            error!("report failed for {}: {e}", output.issue);
        }
    }

    // Integrate successes sequentially: rebase → test → push → PR → merge
    for output in successes {
        let repo_config = config
            .find_repo(&output.repo_config_name)
            .expect("repo config should exist");

        if let Err(e) = integrate_one(&output, repo_config, config, github, state).await {
            error!("integration failed for {}: {e}", output.issue);
            state
                .lock()
                .unwrap()
                .set_error(&output.issue.full_repo(), output.issue.number, &e.to_string())?;
        }
    }

    Ok(())
}

async fn integrate_one(
    output: &WorkerOutput,
    repo_config: &RepoConfig,
    config: &Config,
    github: &GitHubClient,
    state: &SharedState,
) -> Result<()> {
    let issue = &output.issue;
    let (owner, repo) = repo_config.owner_repo();
    let full_repo = issue.full_repo();
    let branch = issue.branch_name();
    let worktree_path = issue.worktree_path(&config.settings.worktree_dir);
    let base_branch = repo_config.base_branch.clone();

    // Rebase onto latest base branch
    info!("rebasing {issue} onto {base_branch}");
    let wt = worktree_path.clone();
    let bb = base_branch.clone();
    tokio::task::spawn_blocking(move || git::branch::rebase(&wt, &bb))
        .await
        .map_err(|e| crate::error::ForgeError::Git(format!("spawn_blocking: {e}")))??;

    // Re-run tests after rebase
    info!("re-running tests for {issue}");
    let wt = worktree_path.clone();
    let test_cmd = repo_config.test_command.clone();
    let test_passed = tokio::task::spawn_blocking(move || {
        crate::pipeline::execute::run_tests(&wt, &test_cmd)
    })
    .await
    .map_err(|e| crate::error::ForgeError::Git(format!("spawn_blocking: {e}")))??;

    if !test_passed {
        info!("tests failed after rebase for {issue}, creating WIP PR");
        let wt = worktree_path.clone();
        let b = branch.clone();
        tokio::task::spawn_blocking(move || git::branch::push(&wt, &b))
            .await
            .map_err(|e| crate::error::ForgeError::Git(format!("spawn_blocking: {e}")))??;

        let pr_title = format!("[WIP] fix #{}: {}", issue.number, issue.title);
        let pr_body = format!(
            "Closes #{}\n\n**Tests failed after rebase.** Manual review needed.\n\n_Automatically generated by pfl-forge_",
            issue.number
        );
        let pr_number = github
            .create_pr(owner, repo, &pr_title, &pr_body, &branch, &base_branch)
            .await?;
        github
            .add_label(owner, repo, pr_number, &["forge-needs-review".to_string()])
            .await?;
        state.lock().unwrap().set_status(
            &full_repo,
            issue.number,
            &issue.title,
            IssueStatus::TestFailure,
        )?;
        return Ok(());
    }

    // Push
    info!("pushing {issue}");
    let wt = worktree_path.clone();
    let b = branch.clone();
    tokio::task::spawn_blocking(move || git::branch::push(&wt, &b))
        .await
        .map_err(|e| crate::error::ForgeError::Git(format!("spawn_blocking: {e}")))??;

    // Create PR
    let pr_title = format!("fix #{}: {}", issue.number, issue.title);
    let pr_body = format!(
        "Closes #{}\n\n_Automatically generated by pfl-forge_",
        issue.number
    );
    let pr_number = github
        .create_pr(owner, repo, &pr_title, &pr_body, &branch, &base_branch)
        .await?;

    github
        .add_label(owner, repo, pr_number, &["forge-auto".to_string()])
        .await?;

    state.lock().unwrap().set_pr(&full_repo, issue.number, pr_number)?;

    // Auto-merge if policy allows
    if config.settings.auto_merge != AutoMergePolicy::Never {
        info!("auto-merging PR #{pr_number} for {issue}");
        if let Err(e) = github.merge_pr(owner, repo, pr_number).await {
            error!("auto-merge failed for PR #{pr_number}: {e}");
        }
    }

    Ok(())
}

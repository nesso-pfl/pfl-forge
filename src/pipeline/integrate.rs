use std::path::Path;

use tracing::{error, info, warn};

use crate::claude::runner::ClaudeRunner;
use crate::config::{AutoMergePolicy, Config, RepoConfig};
use crate::error::Result;
use crate::git;
use crate::github::client::GitHubClient;
use crate::github::issue::{ForgeIssue, TaskSource};
use crate::pipeline::execute::ExecuteResult;
use crate::pipeline::review::{self, ReviewResult};
use crate::pipeline::triage::DeepTriageResult;
use crate::state::tracker::{IssueStatus, SharedState};

fn write_review_yaml(worktree_path: &Path, result: &ReviewResult) -> Result<()> {
  let forge_dir = worktree_path.join(".forge");
  std::fs::create_dir_all(&forge_dir)?;
  let content = serde_yaml::to_string(result)?;
  std::fs::write(forge_dir.join("review.yaml"), content)?;
  Ok(())
}

pub struct WorkerOutput {
  pub issue: ForgeIssue,
  pub result: ExecuteResult,
  pub repo_config_name: String,
  pub deep_triage: DeepTriageResult,
}

pub async fn integrate_one(
  output: &WorkerOutput,
  repo_config: &RepoConfig,
  config: &Config,
  github: &GitHubClient,
  state: &SharedState,
) -> Result<()> {
  let issue = &output.issue;
  let (owner, repo) = repo_config.owner_repo();
  let full_repo = issue.full_repo();
  let branch = issue.branch_name();
  let worktree_path = issue.worktree_path(&config.settings.worktree_dir);
  let base_branch = repo_config.base_branch.clone();

  // Rebase onto latest base branch
  info!("rebasing {issue} onto {base_branch}");
  let wt = worktree_path.clone();
  let bb = base_branch.clone();
  let rebase_result = tokio::task::spawn_blocking(move || git::branch::rebase(&wt, &bb))
    .await
    .map_err(|e| crate::error::ForgeError::Git(format!("spawn_blocking: {e}")))?;

  let is_local = issue.source == TaskSource::Local;

  if let Err(e) = rebase_result {
    warn!("rebase conflict for {issue}: {e}");

    if is_local {
      info!("local task {issue}: rebase conflict, branch left as-is");
    } else {
      let wt = worktree_path.clone();
      let b = branch.clone();
      tokio::task::spawn_blocking(move || git::branch::push(&wt, &b))
        .await
        .map_err(|e| crate::error::ForgeError::Git(format!("spawn_blocking: {e}")))??;

      let pr_title = format!("[WIP] fix #{}: {}", issue.number, issue.title);
      let pr_body = format!(
              "Closes #{}\n\n**Rebase conflict.** Manual resolution needed.\n\nConflict details:\n```\n{}\n```\n\n_Automatically generated by pfl-forge_",
              issue.number, e,
          );
      let pr_number = github
        .create_pr(owner, repo, &pr_title, &pr_body, &branch, &base_branch)
        .await?;
      github
        .add_label(owner, repo, pr_number, &["forge-needs-review".to_string()])
        .await?;
    }
    state
      .lock()
      .unwrap()
      .set_status(&full_repo, issue.number, &issue.title, IssueStatus::Error)?;
    return Ok(());
  }

  // Re-run tests after rebase
  info!("re-running tests for {issue}");
  let wt = worktree_path.clone();
  let test_cmd = repo_config.test_command.clone();
  let test_passed =
    tokio::task::spawn_blocking(move || crate::pipeline::execute::run_tests(&wt, &test_cmd))
      .await
      .map_err(|e| crate::error::ForgeError::Git(format!("spawn_blocking: {e}")))??;

  if !test_passed {
    if is_local {
      info!("local task {issue}: tests failed after rebase, branch left as-is");
    } else {
      info!("tests failed after rebase for {issue}, creating WIP PR");
      let wt = worktree_path.clone();
      let b = branch.clone();
      tokio::task::spawn_blocking(move || git::branch::push(&wt, &b))
        .await
        .map_err(|e| crate::error::ForgeError::Git(format!("spawn_blocking: {e}")))??;

      let pr_title = format!("[WIP] fix #{}: {}", issue.number, issue.title);
      let pr_body = format!(
              "Closes #{}\n\n**Tests failed after rebase.** Manual review needed.\n\n_Automatically generated by pfl-forge_",
              issue.number
          );
      let pr_number = github
        .create_pr(owner, repo, &pr_title, &pr_body, &branch, &base_branch)
        .await?;
      github
        .add_label(owner, repo, pr_number, &["forge-needs-review".to_string()])
        .await?;
    }
    state.lock().unwrap().set_status(
      &full_repo,
      issue.number,
      &issue.title,
      IssueStatus::TestFailure,
    )?;
    return Ok(());
  }

  // Review
  info!("reviewing {issue}");
  let review_runner = ClaudeRunner::new(config.settings.triage_tools.clone());
  let issue_clone = issue.clone();
  let deep_clone = output.deep_triage.clone();
  let config_clone = config.clone();
  let wt = worktree_path.clone();
  let bb = base_branch.clone();
  let review_result = tokio::task::spawn_blocking(move || {
    review::review(
      &issue_clone,
      &deep_clone,
      &config_clone,
      &review_runner,
      &wt,
      &bb,
    )
  })
  .await
  .map_err(|e| crate::error::ForgeError::Claude(format!("spawn_blocking: {e}")))?;

  // Write review result to .forge/review.yaml
  if let Ok(ref result) = review_result {
    if let Err(e) = write_review_yaml(&worktree_path, result) {
      warn!("failed to write review.yaml: {e}");
    }
  }

  match review_result {
    Ok(result) if !result.approved => {
      if is_local {
        info!("local task {issue}: review rejected, branch left for manual review");
      } else {
        info!("review rejected for {issue}, creating WIP PR");
        let wt = worktree_path.clone();
        let b = branch.clone();
        tokio::task::spawn_blocking(move || git::branch::push(&wt, &b))
          .await
          .map_err(|e| crate::error::ForgeError::Git(format!("spawn_blocking: {e}")))??;

        let pr_title = format!("[WIP] fix #{}: {}", issue.number, issue.title);
        let issues_text = if result.issues.is_empty() {
          String::new()
        } else {
          format!(
            "\n\n**Review Issues:**\n{}",
            result
              .issues
              .iter()
              .map(|i| format!("- {i}"))
              .collect::<Vec<_>>()
              .join("\n")
          )
        };
        let suggestions_text = if result.suggestions.is_empty() {
          String::new()
        } else {
          format!(
            "\n\n**Suggestions:**\n{}",
            result
              .suggestions
              .iter()
              .map(|s| format!("- {s}"))
              .collect::<Vec<_>>()
              .join("\n")
          )
        };
        let pr_body = format!(
                  "Closes #{}\n\n**Code review did not pass.** Manual review needed.{issues_text}{suggestions_text}\n\n_Automatically generated by pfl-forge_",
                  issue.number,
              );
        let pr_number = github
          .create_pr(owner, repo, &pr_title, &pr_body, &branch, &base_branch)
          .await?;
        github
          .add_label(owner, repo, pr_number, &["forge-needs-review".to_string()])
          .await?;
      }
      state.lock().unwrap().set_status(
        &full_repo,
        issue.number,
        &issue.title,
        IssueStatus::Error,
      )?;
      return Ok(());
    }
    Err(e) => {
      warn!("review failed for {issue}, proceeding anyway: {e}");
    }
    _ => {
      info!("review approved for {issue}");
    }
  }

  if is_local {
    info!("local task {issue} completed, branch {branch} available locally");
    return Ok(());
  }

  // Push
  info!("pushing {issue}");
  let wt = worktree_path.clone();
  let b = branch.clone();
  tokio::task::spawn_blocking(move || git::branch::push(&wt, &b))
    .await
    .map_err(|e| crate::error::ForgeError::Git(format!("spawn_blocking: {e}")))??;

  // Create PR
  let pr_title = format!("fix #{}: {}", issue.number, issue.title);
  let pr_body = format!(
    "Closes #{}\n\n_Automatically generated by pfl-forge_",
    issue.number
  );
  let pr_number = github
    .create_pr(owner, repo, &pr_title, &pr_body, &branch, &base_branch)
    .await?;

  github
    .add_label(owner, repo, pr_number, &["forge-auto".to_string()])
    .await?;

  state
    .lock()
    .unwrap()
    .set_pr(&full_repo, issue.number, pr_number)?;

  // Auto-merge if policy allows
  if config.settings.auto_merge != AutoMergePolicy::Never {
    info!("auto-merging PR #{pr_number} for {issue}");
    if let Err(e) = github.merge_pr(owner, repo, pr_number).await {
      error!("auto-merge failed for PR #{pr_number}: {e}");
    }
  }

  Ok(())
}

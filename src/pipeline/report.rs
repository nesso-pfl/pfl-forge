use tracing::info;

use crate::config::RepoConfig;
use crate::error::Result;
use crate::github::client::GitHubClient;
use crate::github::issue::{ForgeIssue, TaskSource};
use crate::pipeline::execute::ExecuteResult;
use crate::state::tracker::{IssueStatus, SharedState};

/// Report non-success results (TestFailure/Unclear/Error) to GitHub.
/// Success cases are handled by the integration stage.
/// For local tasks, only log output is produced (no GitHub API calls).
pub async fn report(
  issue: &ForgeIssue,
  result: &ExecuteResult,
  repo_config: &RepoConfig,
  github: &GitHubClient,
  state: &SharedState,
  worktree_dir: &str,
) -> Result<()> {
  let (owner, repo) = repo_config.owner_repo();
  let full_repo = issue.full_repo();
  let branch = issue.branch_name();
  let is_local = issue.source == TaskSource::Local;

  match result {
    ExecuteResult::Success { .. } => {
      // Handled by integrate stage
    }

    ExecuteResult::TestFailure { commits, output } => {
      info!("test failure: {issue} with {commits} commits");

      if is_local {
        info!("local task {issue}: tests failed, branch {branch} left as-is");
      } else {
        let worktree_path = issue.worktree_path(worktree_dir);
        crate::git::branch::push(&worktree_path, &branch)?;

        let pr_title = format!("[WIP] fix #{}: {}", issue.number, issue.title);
        let pr_body = format!(
                  "Closes #{}\n\n**Tests are failing.** Manual review needed.\n\n_Automatically generated by pfl-forge_",
                  issue.number
              );
        let pr_number = github
          .create_pr(
            owner,
            repo,
            &pr_title,
            &pr_body,
            &branch,
            &repo_config.base_branch,
          )
          .await?;

        github
          .add_label(owner, repo, pr_number, &["forge-needs-review".to_string()])
          .await?;

        let truncated = if output.len() > 2000 {
          format!("...{}", &output[output.len() - 2000..])
        } else {
          output.clone()
        };
        github
                  .add_comment(
                      owner,
                      repo,
                      issue.number,
                      &format!("pfl-forge created a WIP PR #{pr_number} but tests are failing:\n\n```\n{truncated}\n```"),
                  )
                  .await?;
      }

      state.lock().unwrap().set_status(
        &full_repo,
        issue.number,
        &issue.title,
        IssueStatus::TestFailure,
      )?;
    }

    ExecuteResult::Unclear(reason) => {
      info!("unclear result: {issue}: {reason}");

      if !is_local {
        github
          .add_comment(
            owner,
            repo,
            issue.number,
            &format!("pfl-forge could not resolve this issue automatically.\n\nReason: {reason}"),
          )
          .await?;

        github
          .add_label(owner, repo, issue.number, &["forge-blocked".to_string()])
          .await?;
      }

      state
        .lock()
        .unwrap()
        .set_error(&full_repo, issue.number, reason)?;
    }

    ExecuteResult::Error(error) => {
      info!("error: {issue}: {error}");

      if !is_local {
        github
          .add_comment(
            owner,
            repo,
            issue.number,
            &format!("pfl-forge encountered an error:\n\n```\n{error}\n```"),
          )
          .await?;
      }

      state
        .lock()
        .unwrap()
        .set_error(&full_repo, issue.number, error)?;
    }
  }

  Ok(())
}

use tracing::info;

use crate::config::RepoConfig;
use crate::error::Result;
use crate::git;
use crate::github::client::GitHubClient;
use crate::github::issue::ForgeIssue;
use crate::pipeline::execute::ExecuteResult;
use crate::state::tracker::{IssueStatus, StateTracker};

pub async fn report(
    issue: &ForgeIssue,
    result: &ExecuteResult,
    repo_config: &RepoConfig,
    github: &GitHubClient,
    state: &mut StateTracker,
    worktree_dir: &str,
) -> Result<()> {
    let (owner, repo) = repo_config.owner_repo();
    let full_repo = issue.full_repo();
    let branch = issue.branch_name();

    match result {
        ExecuteResult::Success { commits } => {
            info!("success: {issue} with {commits} commits");

            // Push branch
            let worktree_path = issue.worktree_path(worktree_dir);
            git::branch::push(&worktree_path, &branch)?;

            // Create PR
            let pr_title = format!("fix #{}: {}", issue.number, issue.title);
            let pr_body = format!(
                "Closes #{}\n\n_Automatically generated by pfl-forge_",
                issue.number
            );
            let pr_number = github
                .create_pr(owner, repo, &pr_title, &pr_body, &branch, &repo_config.base_branch)
                .await?;

            // Add label
            github
                .add_label(owner, repo, pr_number, &["forge-auto".to_string()])
                .await?;

            state.set_pr(&full_repo, issue.number, pr_number)?;
        }

        ExecuteResult::TestFailure { commits, output } => {
            info!("test failure: {issue} with {commits} commits");

            // Push branch
            let worktree_path = issue.worktree_path(worktree_dir);
            git::branch::push(&worktree_path, &branch)?;

            // Create WIP PR
            let pr_title = format!("[WIP] fix #{}: {}", issue.number, issue.title);
            let pr_body = format!(
                "Closes #{}\n\n**Tests are failing.** Manual review needed.\n\n_Automatically generated by pfl-forge_",
                issue.number
            );
            let pr_number = github
                .create_pr(owner, repo, &pr_title, &pr_body, &branch, &repo_config.base_branch)
                .await?;

            github
                .add_label(
                    owner,
                    repo,
                    pr_number,
                    &["forge-needs-review".to_string()],
                )
                .await?;

            // Comment with test output snippet
            let truncated = if output.len() > 2000 {
                format!("...{}", &output[output.len() - 2000..])
            } else {
                output.clone()
            };
            github
                .add_comment(
                    owner,
                    repo,
                    issue.number,
                    &format!("pfl-forge created a WIP PR #{pr_number} but tests are failing:\n\n```\n{truncated}\n```"),
                )
                .await?;

            state.set_status(&full_repo, issue.number, &issue.title, IssueStatus::TestFailure)?;
        }

        ExecuteResult::Unclear(reason) => {
            info!("unclear result: {issue}: {reason}");

            github
                .add_comment(
                    owner,
                    repo,
                    issue.number,
                    &format!("pfl-forge could not resolve this issue automatically.\n\nReason: {reason}"),
                )
                .await?;

            github
                .add_label(owner, repo, issue.number, &["forge-blocked".to_string()])
                .await?;

            state.set_error(&full_repo, issue.number, reason)?;
        }

        ExecuteResult::Error(error) => {
            info!("error: {issue}: {error}");

            github
                .add_comment(
                    owner,
                    repo,
                    issue.number,
                    &format!("pfl-forge encountered an error:\n\n```\n{error}\n```"),
                )
                .await?;

            state.set_error(&full_repo, issue.number, error)?;
        }
    }

    Ok(())
}
